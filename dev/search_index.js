var documenterSearchIndex = {"docs":
[{"location":"noise_types/#Noise-types","page":"Noise types","title":"Noise types","text":"","category":"section"},{"location":"noise_types/","page":"Noise types","title":"Noise types","text":"By default, ConsensusBasedX.jl uses so-called isotropic noise (option noise = :IsotropicNoise), given by","category":"page"},{"location":"noise_types/","page":"Noise types","title":"Noise types","text":"mathrmdX_i(t) = cdots + sqrt2 sigma left X_i(t) - V(t) right mathrmdW_i(t)","category":"page"},{"location":"noise_types/","page":"Noise types","title":"Noise types","text":"where W_i are independent Brownian processes. The intensity of the noise depends on the distance of each particle to the consensus point, left X_i(t) - V(t) right. Full-code example.","category":"page"},{"location":"noise_types/#Anisotropic-noise","page":"Noise types","title":"Anisotropic noise","text":"","category":"section"},{"location":"noise_types/","page":"Noise types","title":"Noise types","text":"ConsensusBasedX.jl also offers anisotropic noise, given by ","category":"page"},{"location":"noise_types/","page":"Noise types","title":"Noise types","text":"mathrmdX_i(t) = cdots + sqrt2 sigma mathrmdiag left( X_i(t) - V(t) right) mathrmdW_i(t)","category":"page"},{"location":"noise_types/","page":"Noise types","title":"Noise types","text":"The intensity of the noise now varies along each dimension. This can be selected with the option noise = :AnisotropicNoise. Full-code example.","category":"page"},{"location":"stopping_criteria/#Stopping-criteria","page":"Stopping criteria","title":"Stopping criteria","text":"","category":"section"},{"location":"stopping_criteria/","page":"Stopping criteria","title":"Stopping criteria","text":"You can apply any of these criteria by passing them as keywords to the minimise routine.","category":"page"},{"location":"stopping_criteria/#Energy-threshold","page":"Stopping criteria","title":"Energy threshold","text":"","category":"section"},{"location":"stopping_criteria/","page":"Stopping criteria","title":"Stopping criteria","text":"energy_threshold::Real = -Inf sets a stopping threshold for the value of f(v), where v is the current consensus point. For each ensemble, if f(v) < energy_threshold, the minimisation stops. Full-code example.","category":"page"},{"location":"stopping_criteria/#Energy-tolerance","page":"Stopping criteria","title":"Energy tolerance","text":"","category":"section"},{"location":"stopping_criteria/","page":"Stopping criteria","title":"Stopping criteria","text":"energy_tolerance::Real = 1e-8 dictates a tolerance for the change in f(v), where v is the current consensus point. For each ensemble, if abs(f(v) - f(v_prev)) < energy_tolerance, where v_prev is the previous consensus point, the minimisation stops. Full-code example.","category":"page"},{"location":"stopping_criteria/#Max-evaluations","page":"Stopping criteria","title":"Max evaluations","text":"","category":"section"},{"location":"stopping_criteria/","page":"Stopping criteria","title":"Stopping criteria","text":"max_evaluations::Real = Inf determines the maximum number of times f may be evaluated by the minimisation. If the value is exceeded, the minimisation stops. Full-code example.","category":"page"},{"location":"stopping_criteria/#Max-iterations","page":"Stopping criteria","title":"Max iterations","text":"","category":"section"},{"location":"stopping_criteria/","page":"Stopping criteria","title":"Stopping criteria","text":"max_iterations::Real = 1000 specifies the maximal number of iterations that the time integrator can perform. If the number is reached, the minimisation stops. Full-code example.","category":"page"},{"location":"stopping_criteria/#Max-time","page":"Stopping criteria","title":"Max time","text":"","category":"section"},{"location":"stopping_criteria/","page":"Stopping criteria","title":"Stopping criteria","text":"max_time::Real = Inf determines the maximal simulation time. If the number of iterations times Î”t surpasses this value, the minimisation stops. Full-code example.","category":"page"},{"location":"performance_benchmarking/#Performance-and-benchmarking","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"","category":"section"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"ConsensusBasedX.jl has been developed with performance in mind. As such, it follows the recommended code patterns, such as avoiding global variables, or keeping memory allocation outside of performance-critical functions.","category":"page"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"In order to maintain good performance, it's important that your function f also follows these patterns. We recommend the performance tips section of the Julia documentation. You should benchmark f, paying attention to memory allocations.","category":"page"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"Once you have benchmarked f, you might want to test its performance within ConsensusBasedX.jl. You could run","category":"page"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"config = (; D = 2)\n@time minimise(f, config)","category":"page"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"but the output of @time will be noisy, as it will include the time and memory allocations due to the caches created by ConsensusBasedX.jl. ","category":"page"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"If, instead, you want to test only the performance-critical parts of the code, you can run the routine in benchmark mode:","category":"page"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"config = (; D = 2, benchmark = true)\nminimise(f, config)","category":"page"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"This will run the beginning of the minimise routine as normal, creating the required caches. However, instead of computing the full particle evolution, it will only calculate a few steps, printing the output of @time to console, and returning the output of @timed.","category":"page"},{"location":"performance_benchmarking/","page":"Performance and benchmarking","title":"Performance and benchmarking","text":"tip: Tip\nThe benchmark mode reports zero allocations with all the Example objectives provided by ConsensusBasedX.jl. Full-code example. Wherever possible, your function should also lead to zero allocations.","category":"page"},{"location":"function_minimisation/#Function-minimisation","page":"Function minimisation","title":"Function minimisation","text":"","category":"section"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"The main functionality of ConsensusBasedX.jl is function minimisation. It assumes you have defined a function f(x::AbstractVector) that takes a single vector argumemt x of length D = length(x).","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"For instance, if D = 2, you can minimise f by running:","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"minimise(f, D = 2)","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"Full-code example.","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"note: Note\nYou must always provide D.","category":"page"},{"location":"function_minimisation/#Using-a-config-object","page":"Function minimisation","title":"Using a config object","text":"","category":"section"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"For more advanced usage, you will select several options. You can pass these as extra keyword arguments to minimise, or you can create a NamedTuple called config and pass that:","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"config = (; D = 2)\nminimise(f, config)","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"Full-code example.","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"note: Note\nIf you pass a Dict instead, it will be converted to a NamedTuple automatically.","category":"page"},{"location":"function_minimisation/#Aliases","page":"Function minimisation","title":"Aliases","text":"","category":"section"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"ConsensusBasedX.jl also defines minimize, optimise, and optimize. These are all aliases of minimise.","category":"page"},{"location":"function_minimisation/#Maximisation","page":"Function minimisation","title":"Maximisation","text":"","category":"section"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"ConsensusBasedX.jl also defines maximise (and its alias, maximize) for convenience. If you call","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"maximise(f, D = 2)","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"or ","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"config = (; D = 2)\nmaximise(f, config)","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"Full-code examples are provided for the keyword and config approaches.","category":"page"},{"location":"function_minimisation/#Method-reference","page":"Function minimisation","title":"Method reference","text":"","category":"section"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"Pages = [\"function_minimisation.md\"]","category":"page"},{"location":"function_minimisation/","page":"Function minimisation","title":"Function minimisation","text":"ConsensusBasedX.maximise\nConsensusBasedX.minimise","category":"page"},{"location":"function_minimisation/#ConsensusBasedX.maximise","page":"Function minimisation","title":"ConsensusBasedX.maximise","text":"maximise(f; keywords...)\n\nmaximise(config::NamedTuple, f)\n\nMaximise the function f using Consensus-Based Optimisation.\n\nAttempts to define x -> -f(x) and calls the minimise routine. This might be better handled directly by the user (see Maximisation).\n\nmaximize is an alias for maximise.\n\nSee also minimise.\n\n\n\n\n\n","category":"function"},{"location":"function_minimisation/#ConsensusBasedX.minimise","page":"Function minimisation","title":"ConsensusBasedX.minimise","text":"minimise(f; keywords...)\n\nminimise(f, config::NamedTuple)\n\nMinimise the function f using Consensus-Based Optimisation (see Function minimisation).\n\nYou must specify the dimension D of the problem. Other paramters (e.g. the number of particles N or the number of ensembles M can also be specified; see Summary of options.\n\nminimize, optimise, or optimize are aliases for minimise.\n\nExamples\n\njulia> minimise(f, D = 2)\n\n\njulia> minimise(f, config)\nconfig = (; D = 2);\n\njulia> minimise(f, D = 2, N = 20)\n\n\njulia> minimise(f, config)\nconfig = (; D = 2, N = 20);\n\n\n\n\n\n","category":"function"},{"location":"summary_options/#Summary-of-options","page":"Summary of options","title":"Summary of options","text":"","category":"section"},{"location":"summary_options/#Basic-options","page":"Summary of options","title":"Basic options","text":"","category":"section"},{"location":"summary_options/","page":"Summary of options","title":"Summary of options","text":"D::Int is the dimension of the problem. This option must always be provided by the user.\nN::Int = 20 is the number of particles.\nM::Int = 1 is the number of ensembles.\nÎ”t::Real = 0.1 is the time step.\nÏƒ::Real = 1 is the noise strengh.\nÎ»::Real = 1 is the drift strengh.\nÎ±::Real = 10 is the exponential weight parameter.","category":"page"},{"location":"summary_options/#Initialisation-options","page":"Summary of options","title":"Initialisation options","text":"","category":"section"},{"location":"summary_options/","page":"Summary of options","title":"Summary of options","text":"See Particle initialisation.","category":"page"},{"location":"summary_options/","page":"Summary of options","title":"Summary of options","text":"initialisation = :normal is the default sampling method. You can change it to initialisation = :uniform in order to sample uniformly from a hyperbox around initial_guess.\ninitial_guess::Union{Real,AbstractVector} provides an initial guess for the global minimiser.\ninitial_mean::Union{Real,AbstractVector} customises the mean of the initial distribution of particles. This is an alias for initial_guess.\ninitial_variance::Union{Real,AbstractVector,AbstractMatrix} customises the mean of the initial distribution of particles (if the sampling is normal). It has the alias initial_covariance.\ninitial_radius::Union{Real,AbstractVector} specifies the size of the hyperbox (if the sampling is uniform). You specify initial_diameter instead.\ninitial_particles::AbstractArray{<:Real,3} specifies the initial position of the particles.","category":"page"},{"location":"summary_options/#Stopping-options","page":"Summary of options","title":"Stopping options","text":"","category":"section"},{"location":"summary_options/","page":"Summary of options","title":"Summary of options","text":"See Stopping criteria.","category":"page"},{"location":"summary_options/","page":"Summary of options","title":"Summary of options","text":"energy_threshold::Real = -Inf is the stopping threshold for the value of f.\nenergy_tolerance::Real = 1e-8 is the stopping tolerance for the value of f.\nmax_evaluations::Real = Inf is the maximum number of evaluations of f.\nmax_iterations::Real = 1000 is the maximum number of iterations.\nmax_time::Real = Inf is the maximal simulation time.","category":"page"},{"location":"summary_options/#Advanced-options","page":"Summary of options","title":"Advanced options","text":"","category":"section"},{"location":"summary_options/","page":"Summary of options","title":"Summary of options","text":"noise = :IsotropicNoise controls the type of noise, see Noise types.\nbenchmark::Bool = false controls the benchmark behaviour. benchmark = true runs the ParticleDynamic on benchmark mode, see Performance and benchmarking.\nextended_output::Bool = false controls the output, and by default returns only the computed minimiser. extended_output = true returns additional information, see Extended output.\nparallelisation = :NoParallelisation controls the parallelisation of the minimise routine, switched off by default. parallelisation=:EnsembleParallelisation enables parallelisation, see  Parallelisation.\nverbosity::Int = 0 is the verbosity level. verbosity = 0 produces no output to console. verbosity = 1 produces some output. ","category":"page"},{"location":"extended_output/#Extended-output","page":"Extended output","title":"Extended output","text":"","category":"section"},{"location":"extended_output/","page":"Extended output","title":"Extended output","text":"By default, the minimise routine returns its best guess for the global minimiser of the function f. However, it is possible to access the extended output by passing the extended_output = true option.","category":"page"},{"location":"extended_output/","page":"Extended output","title":"Extended output","text":"The extended output is a NamedTuple which contains:","category":"page"},{"location":"extended_output/","page":"Extended output","title":"Extended output","text":"minimiser, the usual output of the minimise;\nensemble_minimiser, a Vector of the M minimisers computed by each ensemble. minimiser is equal to their mean;\ninitial_particles, the initial position of the particles, see Particle initialisationref;\nfinal_particles, the final position of the particles;\nmethod, by default a ConsensusBasedOptimisation object;\nmethod_cache, by default a ConsensusBasedOptimisationCache object;\nparticle_dynamic, by default a ParticleDynamic object;\nparticle_dynamic_cache, by default a ParticleDynamicCache object.","category":"page"},{"location":"extended_output/","page":"Extended output","title":"Extended output","text":"TODO: ref objects.","category":"page"},{"location":"particle_initialisation/#Particle-initialisation","page":"Particle initialisation","title":"Particle initialisation","text":"","category":"section"},{"location":"particle_initialisation/","page":"Particle initialisation","title":"Particle initialisation","text":"ConsensusBasedX.jl needs to initialise particles in order to perform function minimisation.","category":"page"},{"location":"particle_initialisation/#Default-initialisation","page":"Particle initialisation","title":"Default initialisation","text":"","category":"section"},{"location":"particle_initialisation/","page":"Particle initialisation","title":"Particle initialisation","text":"If no options are provided, ConsensusBasedX.jl initialises its particles by sampling a standard normal distribution (a normal distribution with zero mean and unit variance).","category":"page"},{"location":"particle_initialisation/#Initial-guess","page":"Particle initialisation","title":"Initial guess","text":"","category":"section"},{"location":"particle_initialisation/","page":"Particle initialisation","title":"Particle initialisation","text":"If you have an initial guess for the global minimiser of the function f, you can pass the option initial_guess (or initial_mean). This can be a Real, if you want to use the same value for each coordinate of the initial guess, or an AbstractVector of size size(initial_guess) = (D,). The particles will be initisalised by sampling a normal distribution with mean initial_guess/initial_mean and unit variance. Full-code example.","category":"page"},{"location":"particle_initialisation/#Specify-a-normal-distribution","page":"Particle initialisation","title":"Specify a normal distribution","text":"","category":"section"},{"location":"particle_initialisation/","page":"Particle initialisation","title":"Particle initialisation","text":"If you want to specify the variance of the normal distribution sampled around initial_guess/initial_mean, you can pass the option initial_variance (or initial_covariance). This can be a Real, if you want an isotropic distribution, an AbstractVector of size size(initial_variance) = (D,), if you want to specify the variance along each axis, or an AbstractMatrix of size size(initial_variance) = (D, D), if you want a general multivariate normal distribution. Full-code example.","category":"page"},{"location":"particle_initialisation/#Specify-a-uniform-distribution","page":"Particle initialisation","title":"Specify a uniform distribution","text":"","category":"section"},{"location":"particle_initialisation/","page":"Particle initialisation","title":"Particle initialisation","text":"You can instead initialise the particles by sampling uniformly from a box around initial_guess/initial_mean. To do so, pass the option initialisation = :uniform. Full-code example.","category":"page"},{"location":"particle_initialisation/","page":"Particle initialisation","title":"Particle initialisation","text":"You can specify the radius of the box with the option initial_radius, or the diameter with initial_diameter. This can be a Real, if you want a hypercube, or an AbstractVector of size size(initial_guess) = (D,), if you want a hyperbox with different dimensions along each axis. Full-code example.","category":"page"},{"location":"particle_initialisation/#Custom-initialisation","page":"Particle initialisation","title":"Custom initialisation","text":"","category":"section"},{"location":"particle_initialisation/","page":"Particle initialisation","title":"Particle initialisation","text":"You can provide the initial position of the particles direcly by passing the option initial_particles. This must be an AbstractArray{<:Real,3} of size (D, N, M). Full-code example.","category":"page"},{"location":"particle_initialisation/","page":"Particle initialisation","title":"Particle initialisation","text":"tip: Tip\nIf you are initialising the particles yourself, you might find the Distributions.jl package useful.","category":"page"},{"location":"output_visualisation/#Output-visualisation","page":"Output visualisation","title":"Output visualisation","text":"","category":"section"},{"location":"output_visualisation/","page":"Output visualisation","title":"Output visualisation","text":"ConsensusBasedX.jl offers the ConsensusBasedXPlots submodule, which provides routines to visualise the output of minimise for problems in one or two dimensions.","category":"page"},{"location":"output_visualisation/","page":"Output visualisation","title":"Output visualisation","text":"Simply run minimise with extended_output = true (see Extended output), and then call the plot_CBO method:","category":"page"},{"location":"output_visualisation/","page":"Output visualisation","title":"Output visualisation","text":"out = minimise(f, D = 2, extended_output = true)\nusing ConsensusBasedX.ConsensusBasedXPlots\nplot_CBO(out)","category":"page"},{"location":"output_visualisation/","page":"Output visualisation","title":"Output visualisation","text":"Full-code examples in one dimension and two dimensions.","category":"page"},{"location":"output_visualisation/","page":"Output visualisation","title":"Output visualisation","text":"compat: Compat\nThe developers of ConsensusBasedX.jl intend to segregate ConsensusBasedXPlots as a separate package in the future, in order to avoid having Plots as a dependency of ConsensusBasedX.","category":"page"},{"location":"parallelisation/#Parallelisation","page":"Parallelisation","title":"Parallelisation","text":"","category":"section"},{"location":"parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"Consensus-based optimisation is often used to tackle minimisation problems where f(x) is expensive to evaluate (for instance, parameter estimation in a partial differential equation model). Therefore, ConsensusBasedX.jl does not use parallelisation by default, as it assumes the implementation of f will be parallelised if possible.","category":"page"},{"location":"parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"However, you can enable parallelisation by passing the option parallelisation=:EnsembleParallelisation. With this option, ConsensusBasedX.jl will run each of the M particle ensembles in parallel. Full-code example.","category":"page"},{"location":"parallelisation/","page":"Parallelisation","title":"Parallelisation","text":"warning: Warning\nParallelisation leads to memory allocations which cannot be avoided, as there is overhead associated with distributing the tasks. If you activate parallelisation, and then run minimise in benchmark mode (see Performance and benchmarking), you will detect some allocations, and this is expected.","category":"page"},{"location":"low_level_examples/#Low-level-interface-examples","page":"Low-level interface examples","title":"Low-level interface examples","text":"","category":"section"},{"location":"low_level_examples/","page":"Low-level interface examples","title":"Low-level interface examples","text":"We provide two low-level interface examples for the convenience of advanced users.","category":"page"},{"location":"low_level_examples/#Manual-method-definition","page":"Low-level interface examples","title":"Manual method definition","text":"","category":"section"},{"location":"low_level_examples/","page":"Low-level interface examples","title":"Low-level interface examples","text":"This example bypasses the minimise interface, and defines the ParticleDynamic and ConsensusBasedOptimisation structs directly. However, ConsensusBasedX.construct_particle_dynamic_cache is used to construct the caches:","category":"page"},{"location":"low_level_examples/","page":"Low-level interface examples","title":"Low-level interface examples","text":"config =\n  (; D = 2, N = 20, M = 1, Î± = 10.0, Î» = 1.0, Ïƒ = 1.0, Î”t = 0.1, verbosity = 0)\n\nf(x) = ConsensusBasedX.Ackley(x, shift = 1)\n\nXâ‚€ = [[rand(config.D) for n âˆˆ 1:(config.N)] for m âˆˆ 1:(config.M)]\n\ncorrection = HeavisideCorrection()\nmethod = ConsensusBasedOptimisation(f, correction, config.Î±, config.Î», config.Ïƒ)\n\nÎ”t = 0.1\nparticle_dynamic = ParticleDynamic(method, Î”t)\n\nparticle_dynamic_cache =\n  construct_particle_dynamic_cache(config, Xâ‚€, particle_dynamic)\n\nmethod_cache = particle_dynamic_cache.method_cache\n\ninitialise_particle_dynamic_cache!(Xâ‚€, particle_dynamic, particle_dynamic_cache)\ninitialise_dynamic!(particle_dynamic, particle_dynamic_cache)\ncompute_dynamic!(particle_dynamic, particle_dynamic_cache)\nfinalise_dynamic!(particle_dynamic, particle_dynamic_cache)\n\nout = wrap_output(Xâ‚€, particle_dynamic, particle_dynamic_cache)","category":"page"},{"location":"low_level_examples/","page":"Low-level interface examples","title":"Low-level interface examples","text":"Full-code example.","category":"page"},{"location":"low_level_examples/#Manual-stepping","page":"Low-level interface examples","title":"Manual stepping","text":"","category":"section"},{"location":"low_level_examples/","page":"Low-level interface examples","title":"Low-level interface examples","text":"This bypasses the compute_dynamic! method, performing the stepping manually instead:","category":"page"},{"location":"low_level_examples/","page":"Low-level interface examples","title":"Low-level interface examples","text":"config =\n  (; D = 2, N = 20, M = 1, Î± = 10.0, Î» = 1.0, Ïƒ = 1.0, Î”t = 0.1, verbosity = 0)\n\nf(x) = ConsensusBasedX.Ackley(x, shift = 1)\n\nXâ‚€ = [[rand(config.D) for n âˆˆ 1:(config.N)] for m âˆˆ 1:(config.M)]\n\ncorrection = HeavisideCorrection()\nmethod = ConsensusBasedOptimisation(f, correction, config.Î±, config.Î», config.Ïƒ)\n\nÎ”t = 0.1\nparticle_dynamic = ParticleDynamic(method, Î”t)\n\nparticle_dynamic_cache =\n  construct_particle_dynamic_cache(config, Xâ‚€, particle_dynamic)\n\nmethod_cache = particle_dynamic_cache.method_cache\n\ninitialise_particle_dynamic_cache!(Xâ‚€, particle_dynamic, particle_dynamic_cache)\ninitialise_dynamic!(particle_dynamic, particle_dynamic_cache)\n\nfor it âˆˆ 1:100\n  for m âˆˆ 1:(config.M)\n    compute_dynamic_step!(particle_dynamic, particle_dynamic_cache, m)\n  end\nend\n\nfinalise_dynamic!(particle_dynamic, particle_dynamic_cache)\n\nout = wrap_output(Xâ‚€, particle_dynamic, particle_dynamic_cache)","category":"page"},{"location":"low_level_examples/","page":"Low-level interface examples","title":"Low-level interface examples","text":"Full-code example.","category":"page"},{"location":"low_level/#Low-level-interface","page":"Low-level interface","title":"Low-level interface","text":"","category":"section"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"Internally, the minimise routine relies on two constructs: the ParticleDynamic and a CBXMethod.","category":"page"},{"location":"low_level/#ConsensusBasedXLowLevel","page":"Low-level interface","title":"ConsensusBasedXLowLevel","text":"","category":"section"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ConsensusBasedX.jl defines the ConsensusBasedXLowLevel submodule for the convenience of advanced users. It can be imported by","category":"page"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"using ConsensusBasedX, ConsensusBasedX.ConsensusBasedXLowLevel","category":"page"},{"location":"low_level/#ParticleDynamic","page":"Low-level interface","title":"ParticleDynamic","text":"","category":"section"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"The ParticleDynamic struct defines the evolution in time of particles, and is agnostic of the specific method in question. Its functionality currently serves ConsensusBasedOptimisation, but can be extended to other methods.","category":"page"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ConsensusBasedX.ParticleDynamic","category":"page"},{"location":"low_level/#ConsensusBasedX.ParticleDynamic","page":"Low-level interface","title":"ConsensusBasedX.ParticleDynamic","text":"ParticleDynamic\n\nFields:\n\nmethod<:CBXMethod, the optimisation method.\nÎ”t::Float64, the time step.\n\n\n\n\n\n","category":"type"},{"location":"low_level/#ParticleDynamicCache","page":"Low-level interface","title":"ParticleDynamicCache","text":"","category":"section"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ParticleDynamic requires a cache, ParticleDynamicCache. This can be constructed with:","category":"page"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ConsensusBasedX.construct_particle_dynamic_cache","category":"page"},{"location":"low_level/#ConsensusBasedX.construct_particle_dynamic_cache","page":"Low-level interface","title":"ConsensusBasedX.construct_particle_dynamic_cache","text":"construct_particle_dynamic_cache(\n  config::NamedTuple,\n  Xâ‚€::AbstractArray,\n  particle_dynamic::ParticleDynamic,\n)\n\nA constructor helper for ParticleDynamicCache. Calls ConsensusBasedX.construct_method_cache to construct the corresponding CBXMethodCache.\n\n\n\n\n\n","category":"function"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"The full reference is:","category":"page"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ConsensusBasedX.ParticleDynamicCache","category":"page"},{"location":"low_level/#ConsensusBasedX.ParticleDynamicCache","page":"Low-level interface","title":"ConsensusBasedX.ParticleDynamicCache","text":"ParticleDynamicCache\n\nIt is strongly recommended that you do not construct ParticleDynamicCache by hand. Instead, use ConsensusBasedX.construct_particle_dynamic_cache.\n\nFields:\n\nmode should be set to ParticleMode.\nparallelisation<:Parallelisations, the parallelisation mode.\nmethod_cache<:CBXMethodCache, a cache for the method field of ParticleDynamic.\nD::Int, the dimension of the problem.\nN::Int, the number of particles per ensemble.\nM::Int, the number of ensembles.\nX, the particle array.\ndX, the time derivative array.\nÎ”t::Float64, the time step.\nrootÎ”t::Float64, the square root of the time step.\nroot2Î”t::Float64, the square root of twice the time step.\nmax_iterations::Float64, the maximum number of iterations.\nmax_time::Float64, the maximal time.\niteration::Vector{Int}, the vector containing the iteration count per ensemble.\n\n\n\n\n\n","category":"type"},{"location":"low_level/#ConsensusBasedOptimisation","page":"Low-level interface","title":"ConsensusBasedOptimisation","text":"","category":"section"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"The ConsensusBasedOptimisation struct (of type CBXMethod) defines the details of the consensus-based optimisation method (function evaluations, consensus point...).","category":"page"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ConsensusBasedX.ConsensusBasedOptimisation","category":"page"},{"location":"low_level/#ConsensusBasedX.ConsensusBasedOptimisation","page":"Low-level interface","title":"ConsensusBasedX.ConsensusBasedOptimisation","text":"ConsensusBasedOptimisation\n\nFields:\n\nf, the objective function.\ncorrection<:CBXCorrection, a correction term.\nÎ±::Float64, the the exponential weight parameter.\nÎ»::Float64, the drift strengh.\nÏƒ::Float64, the noise strengh.\n\n\n\n\n\n","category":"type"},{"location":"low_level/#ConsensusBasedOptimisationCache","page":"Low-level interface","title":"ConsensusBasedOptimisationCache","text":"","category":"section"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ConsensusBasedOptimisation requires a cache, ConsensusBasedOptimisationCache (of type CBXMethodCache). This can be constructed with:","category":"page"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ConsensusBasedX.construct_method_cache","category":"page"},{"location":"low_level/#ConsensusBasedX.construct_method_cache","page":"Low-level interface","title":"ConsensusBasedX.construct_method_cache","text":"construct_method_cache(\n  config::NamedTuple,\n  Xâ‚€::AbstractArray,\n  method::CBXMethod,\n  particle_dynamic::ParticleDynamic,\n)\n\nA constructor helper for CBXMethodCache.\n\n\n\n\n\n","category":"function"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"Note that this method is called automatically by ConsensusBasedX.construct_particle_dynamic_cache.","category":"page"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"The full reference is:","category":"page"},{"location":"low_level/","page":"Low-level interface","title":"Low-level interface","text":"ConsensusBasedX.ConsensusBasedOptimisationCache","category":"page"},{"location":"low_level/#ConsensusBasedX.ConsensusBasedOptimisationCache","page":"Low-level interface","title":"ConsensusBasedX.ConsensusBasedOptimisationCache","text":"ConsensusBasedOptimisationCache{T}\n\nIt is strongly recommended that you do not construct ConsensusBasedOptimisationCache by hand. Instead, use ConsensusBasedX.construct_method_cache.\n\nFields:\n\nconsensus::Vector{Vector{T}}, the consensus point of each ensemble.\nconsensus_energy::Vector{T}, the energy (value of the objective function) of each consensus point.\nconsensus_energy_previous::Vector{T}, the previous energy.\ndistance::Vector{Vector{T}}, the distance of each particle to the consensus point.\nenergy::Vector{Vector{T}}, the energy of each particle.\nexponents::Vector{Vector{T}}, an exponent used to compute logsums.\nlogsums::Vector{T}, a normalisation factor for weights.\nweights::Vector{Vector{T}}, the exponential weight of each particle.\nenergy_threshold::Float64, the energy threshold.\nenergy_tolerance::Float64, the energy tolerance.\nmax_evaluations::Float64, the maximum number of f evaluations.\nevaluations::Vector{Int}, the current number of f evaluations.\n\n\n\n\n\n","category":"type"},{"location":"example_objectives/#Example-objectives","page":"Example objectives","title":"Example objectives","text":"","category":"section"},{"location":"example_objectives/","page":"Example objectives","title":"Example objectives","text":"ConsensusBasedX.jl provides a few example functions that can be used to test the minimisation algorithms and parameters.","category":"page"},{"location":"example_objectives/","page":"Example objectives","title":"Example objectives","text":"Pages = [\"example_objectives.md\"]","category":"page"},{"location":"example_objectives/","page":"Example objectives","title":"Example objectives","text":"ConsensusBasedX.Ackley\nConsensusBasedX.Quadratic\nConsensusBasedX.Rastrigin","category":"page"},{"location":"example_objectives/#ConsensusBasedX.Ackley","page":"Example objectives","title":"ConsensusBasedX.Ackley","text":"Ackley(x::AbstractVector; a = 20, b = 0.2, c = 2Ï€, shift = 0)\n\nThe Ackley function in dimension D = length(x) with global minimum at the point x = (textrmshift textrmshift cdots textrmshift):\n\nf(x) =\na left\n1 - exp left(\n-b sqrt\nfrac1D\nsum_d=1^D (x_d - textrmshift)^2\n\nright)\nright\n+ left\nexp(1)\n-\nexp left(\nfrac1D\nsum_d=1^D cos( c (x_d - textrmshift) )\nright)\nright\n\n\nSee also the Wikipedia article.\n\n\n\n\n\n","category":"function"},{"location":"example_objectives/#ConsensusBasedX.Quadratic","page":"Example objectives","title":"ConsensusBasedX.Quadratic","text":"Quadratic(x::AbstractVector; shift = 0)\n\nA quadratic function in dimension D = length(x) with global minimum at the point x = (textrmshift textrmshift cdots textrmshift):\n\nf(x) =\nfrac1D\nsum_d=1^D (x_d - textrmshift)^2\n\n\n\n\n\n\n","category":"function"},{"location":"example_objectives/#ConsensusBasedX.Rastrigin","page":"Example objectives","title":"ConsensusBasedX.Rastrigin","text":"Rastrigin(x::AbstractVector; a = 10, c = 2Ï€, shift = 0)\n\nThe Rastrigin function in dimension D = length(x) with global minimum at the point x = (textrmshift textrmshift cdots textrmshift):\n\nf(x) =\nfrac1D\nsum_d=1^D (x_d - textrmshift)^2\n+ a left(\n1\n-\nfrac1D\nsum_d=1^D cos( c (x_d - textrmshift) )\nright)\n\n\nSee also the Wikipedia article.\n\n\n\n\n\n","category":"function"},{"location":"method_parameters/#Method-parameters","page":"Method parameters","title":"Method parameters","text":"","category":"section"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"You can change any of these parameters by passing them as keywords to the minimise routine.","category":"page"},{"location":"method_parameters/#Number-of-particles","page":"Method parameters","title":"Number of particles","text":"","category":"section"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"ConsensusBasedX.jl uses N = 20 particles by default. At each iteration of the method, the function f is evaluated at the position of each particle.","category":"page"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"tip: Tip\nUsing more particles is likely to yield better results, but it will increase the computational cost of the minimisation.","category":"page"},{"location":"method_parameters/#Number-of-ensembles","page":"Method parameters","title":"Number of ensembles","text":"","category":"section"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"ConsensusBasedX.jl uses M = 1 ensembles by default. Each ensemble will perform its own minimisation of f, and the final results will be averaged.","category":"page"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"tip: Tip\nUsing more ensembles is likely to yield better results, but it will increase the computational cost of the minimisation.","category":"page"},{"location":"method_parameters/#Time-step","page":"Method parameters","title":"Time step","text":"","category":"section"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"ConsensusBasedX.jl uses a time step of Î”t = 0.1 by default. The evolution of the particles is given by a certain stochastic differential equation, which is solved using an Euler-Maruyama scheme with time step Î”t.","category":"page"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"tip: Tip\nReducing Î”t will require more iterations of the method to converge, but will provide additional stability. Reduce Î”t only if your minimisation \"blows up\" (returns unusually large numbers, Inf, or NaN).","category":"page"},{"location":"method_parameters/#Consensus-parameters","page":"Method parameters","title":"Consensus parameters","text":"","category":"section"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"Consensus-based optimisation requires three parameters:","category":"page"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"Ïƒ::Real = 1 is the noise strengh;\nÎ»::Real = 1 is the drift strengh;\nÎ±::Real = 10 is the exponential weight parameter.","category":"page"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"tip: Tip\nA low value of Ïƒ and a high value of Î» make the particles converge towards the consensus point more directly; this is a good idea if you have a very good guess for the global minimiser (see Particle initialisation). A high value of Ïƒ and a low value of Î» make the particles explore more of the landscape before converging, which is useful if your initial guess is bad. Similarly, a higher value of Î± biases the consensus point towards the current best particle, which is only desirable if your initial guess is good.","category":"page"},{"location":"method_parameters/","page":"Method parameters","title":"Method parameters","text":"Full-code example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ConsensusBasedX","category":"page"},{"location":"#ConsensusBasedX.jl:-Consensus-Based-Optimisation-in-Julia","page":"Home","title":"ConsensusBasedX.jl: Consensus-Based Optimisation in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<iframe src=\"https://ghbtns.com/github-btn.html?user=PdIPS&repo=ConsensusBasedX.jl&type=star&count=true&size=large\" frameborder=\"0\" scrolling=\"0\" width=\"170\" height=\"30\" title=\"GitHub\"></iframe>","category":"page"},{"location":"","page":"Home","title":"Home","text":"ConsensusBasedX.jl is a gradient-free stochastic optimisation package for Julia, born out of Consensus.jl and CBXpy. It uses Consensus-Based Optimisation (CBO), a flavour of Particle Swarm Optimisation (PSO) first introduced by R. Pinnau, C. Totzeck, O. Tse, and S. Martin (2017). This is a method of global optimisation particularly suited for rough functions, where gradient descent would fail. It is also useful for optimisation in higher dimensions.","category":"page"},{"location":"#Consensus-Based-Optimisation","page":"Home","title":"Consensus-Based Optimisation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consensus-based optimisation uses particles to minimise a function f(x). The particles evolve following a stochastic differential equation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathrmdX_i(t) = -lambda left( X_i - V right) H left f(X_i) - f(V) right mathrmdt + sqrt2 sigma left X_i(t) - V(t) right mathrmdW_i(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where W_i are independent Brownian processes, and where","category":"page"},{"location":"","page":"Home","title":"Home","text":"V(t) = frac\nsumlimits_i X_i exp(-alpha f(X_i))\n\nsumlimits_i exp(-alpha f(X_i))\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"is a weighted average of the particle's positions called the consensus point. lambda, sigma, and alpha are given positive parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Static Badge) (Image: Build Status) (Image: Coverage) (Image: Aqua) (Image: License: MIT)","category":"page"}]
}
